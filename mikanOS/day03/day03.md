# day03
## 3.1 QEMUモニタ
- QEMUモニタを使ったデバッグ方法を記載する。
- QEMUモニタは、QEMUの標準機能で、CPUの設定を表示したりメモリの中身を読み書きをすることができる。
- QEMUモニタはを使うには、QEMUが起動した後にrun_qemu.shを実行したターミナルに戻る。  
  （QEMUモニタをターミナルから使えるようにしてある。）
    ![Image 1](qemuMonitor1.png)
## 3.1.1 QEMUモニタを使ったレジスタ値の確認
- QEMUモニタで以下のコマンドを実行すると、CPUの各レジスタの現在の値が表示される。
  ```
  info registers
  ```
   ![Image 1](infoResisters.png)
## 3.1.2 QEMUモニタを使ったメモリダンプ方法
- メインメモリの中で指定したアドレス付近の値を表示する、メモリダンプの方法を記載する。
- メモリダンプを実施するにはxコマンドを使う。Xコマンドの書式は以下の通り。
  ```
  (qemu) x /fmt addr
  ```
  - /fmtに指定された書式にしたがってaddrを先頭とするメモリ領域の値を表示する。  
    /fmtは、/[個数][フォーマット][サイズ]と分解できる。
  - [個数]は、何個分表示するかを指定する。
  - [フォーマット]は、読み出した値をどのような形式で表示するかを以下の種類から選択できる。
    | オプション | 表示形式 | 
    | ------------- | -------- | 
    | x | 16進数表示 |
    | d | 10進数表示 |
    | i | 機械語命令を逆アセンブルして表示 |
  - [サイズ]は、何バイトを1単位として解釈するかを指定する。
  
    | オプション | 単位 | 
    | ------------- | -------- | 
    | b | 1バイト |
    | h | 2バイト |
    | w | 4バイト |
    | g | 8バイト |
- 0x067ae4c4から4バイトを16進数で表示する場合は、以下のようにコマンドを実行する。
  ```
  (qemu) x /4xb 0x067ae4c4
  00000000067ae4c4: 0xeb 0xfe 0x66 0x90
  ```
  - 上記はおそらく機械語命令であると思われる。
    試しに2命令分を逆アセンブルして表示してみる。
    ```
    (qemu)bx /2i 0x067ae4c4
    00000000067ae4c4:  jmp      0x67ae4c4
    00000000067ae4c6:  xchg     %ax,%ax
    ```
      - 「jmp 0x67ae4c4」は、0x67ae4c4にジャンプするという命令であるが、0x67ae4c4はその命令がある場所そのものであるので、結局は同じ場所をぐるぐると回ることになる。実はこのアセンブリ命令はwhile(1);をコンパイルしたものになる。
## 3.2 レジスタ
- CPUに内蔵されたレジスタについて記載する。
- CPUには、一般的に汎用レジスタと特殊レジスタが搭載されている。
- 汎用レジスタは、一般の演算に使用するレジスタである。
- 特殊レジスタは、その目的は様々で、CPUの設定を行うためのものやタイマなどのCPUに内蔵された機能を制御するためのものもある。
### 3.2.1 汎用レジスタ
- 汎用レジスタの主目的は、値を記憶することである。
- CPUの外部にあるメインメモリと対照的に、レジスタは容量が小さく読み書きが高速な点が特徴である。  
  容量については、メインメモリは16GB（2の34乗バイト）程度あるのに対して、x86-64アーキテクチャの汎用レジスタは128B（2の7乗）しかない。  
  読み書き速度については、メインメモリはだいたい100ナノ秒くらいかかるのに対して、レジスタは待ち時間なく書き込み可能である。（2GHzで動くCPUであれば0.5ナノ秒程度）  
- x86-64の汎用レジスタは以下の16個である。
  - RAX、RBX、RCX、RDX、RBP、RSI、RDI、RSP、R8～R15
- これらの汎用レジスタは、CPUの演算対象に指定できる。
  例えば、加算命令addには次のように2つのレジスタを指定できる。  
  ```
  add  rax,  rbx
  ; オペコード  オペランド1,  オペランド2
  ```
- 一般的にx86-64の演算命令は2つのオペランド(引数)を取り、左側が書き込み先、右側が読み込み元になる。
- x86-64の汎用レジスタのサイズはすべて8バイト(=64ビット)である。
- charやunit16_tといった8バイトより小さいサイズの型の変数（変数はメインメモリに配置される）をレジスタに読み出して使う場合には、汎用レジスタを小さなレジスタとしてアクセスできるような仕組みになっている。  
  例えば、AXレジスタはRAXレジスタの下位16ビットを表す名前になっていて、AXを読み書きすることでRAXの下位16ビットを読み書きできる。  
    ![Image 1](generalPurposeResister.png)
### 3.2.1 特殊レジスタ
- 特殊レジスタの役割はレジスタによってそれぞれで、汎用レジスタ同様に値を記憶するものもあれば、汎用レジスタにはない機能を持つものもいる。代表的なものを記載する。
- RIPは、次に実行する命令のメモリアドレスを保持していて、命令の実行に伴って変化する。  
  演算系の命令を実行した場合は、次の命令を指すように増えるだけだが、jmpやcallのような分岐命令の場合は、オペランドで指定されたアドレスがRIPに書き込まれる。
- RFLAGSは、様々なフラグを集めたレジスタで、各ビット毎に異なる役割を持つ。例えば、ビット0がキャリーフラグ(CF)、ビット6がゼロフラグ(ZF)である。  
  CFは加算がオーバーフローした場合に1になる。ZFは命令の実行結果が0になると1になる。  
  フラグレジスタは、演算系の命令やcmpなどのフラグレジスタに影響を与える命令の直後に、jzやcmovzなどのフラグレジスタの内容によって動作が変わる命令を配置する。
- CR0は、CPUの重要な設定を集めたレジスタである。  
  CR0のビット0(PE)に1を書き込むと、CPUは保護モードに遷移する。ビット31(PG)に1を書き込むとページングが有効になる。
